一、什么是webpack,为什么要学习和使用它？
  现在很多的网页页面，其实可以看作是拥有丰富功能的应用，他们拥有大量的JavaScript代码和一大堆的依赖包，为了改善这种异常复杂的开发工作，前端工程师提出了很多的解决方案：
  1、模块化：将零碎的代码进行封装，细化为结构、职能明确的小文件；
  2、类似于Typescript这种在JavaScript基础上拓展的开发语言：解决当前版本的JavaScript所不能解决的一些问题，而且还可以换装JavaScript文件，使得浏览器可以 识别；
  3、less、scss等css预处理器；
  ...
  这些工具的确简化了我们的开发难度，但是这些工具还需要进行额外的处理，这就为Webpack工具的出现提供了需求。

二、什么是webpack:
  WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。

三、WebPack和Grunt以及Gulp相比有什么特性
  1、其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。
  2、Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。
  3、Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。
  
四、webpack的使用：
  1、安装
  在npm下进行安装，新建一个文件夹，在终端下转到你文件夹所在的位置：
  //全局安装
  npm install -g webpack
  //安装到你的项目目录
  npm install --save-dev webpack
  2、正式使用webpack
    2.1、webpack可以在终端中使用，其最基本的命令是：
    webpack {entry file/入口文件} {destination for bundled file/存放bundle.js的地方}
    2.2、全局安装的情况下：
    webpack app/main.js public/bundle.js
         非全局安装情况下：
    node_modules/.bin/webpack app/main.js public/bundle.js

五、webpack的另一种用法：通过配置文件来使用WebPack
  1、Webpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。
  2、配置文件的书写：这个配置文件是在项目文件夹的根部目录下面创建的！
  module.exports = {
  entry:  __dirname + "/app/main.js",//已多次提及的唯一入口文件
  output: {
    path: __dirname + "/public",//打包后的文件存放的地方
    filename: "bundle.js"//打包后输出文件的文件名
  }
}
   【注意】：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。
   3、当配置文件设置妥当之后，你只需要在终端运行以下的代码即可实现上面那些环节所实现的目标：
   node_modules/.bin/webpack
   
六、实现更快捷的打包方式：
  1、执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下
{
  "name": "webpack-sample-project",
  "version": "1.0.0",
  "description": "Sample webpack project",
  "scripts": {
    "start": "webpack" //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令
  },
  "author": "MJ",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^3.3.0"
  }
}
【注意】：package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。

七、webpack的强大功能
  1、生成Source Maps(使调试变得更加容易)
    1.1、开发总是离不开调试，如果可以更加方便的调试当然就能提高开发效率，不过打包后的文件有时候你是不容易找到出错了的地方对应的源代码的位置的，              Source Maps就是来帮我们解决这个问题的。
         通过简单的配置后，Webpack在打包时可以为我们生成的source maps，这为我们提供了一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也          更容易调试。
    1.2、在webpack的配置文件中配置source maps，需要配置devtool，它有以下四种不同的配置选项，各具优缺点，描述如下：
      devtool选项              配置结果
      
      source-map               在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度；
      
 cheap-module-source-map       在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的                                  行，不能对应到具体的列（符号），会对调试造成不便；
 
 eval-source-map               使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的                                  sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段                                一定不要用这个选项；
 
 cheap-module-eval-source-map  这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和                                eval-source-map选项具有相似的缺点；

正如上表所述，上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。

在学习阶段以及在小到中性的项目上，eval-source-map是一个很好的选项，不过记得只在开发阶段使用它，继续上面的例子，进行如下配置
module.exports = {
  devtool: 'eval-source-map',//配置生成Source Maps，选择合适的选项
  entry:  __dirname + "/app/main.js",
  output: {
    path: __dirname + "/public",
    filename: "bundle.js"
  }
}

2、利用webpack构建本地服务器
  1、想不想让你的浏览器监测你的代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现      你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。
     npm install --save-dev webpack-dev-server
     devserver作为webpack配置选项中的一项，具有以下配置选项
devserver       功能描述

contentBase     默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置                   到“public"目录）
port            设置默认监听端口，如果省略，默认为”8080“
inline          设置为true，当源文件改变时会自动刷新页面
colors          设置为true，使终端输出的文件为彩色的
historyApiFallback  在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.htm
    继续把这些命令加到webpack的配置文件中，现在的配置文件如下所示
    
module.exports = {
  devtool: 'eval-source-map',
  entry:  __dirname + "/app/main.js",
  output: {
    path: __dirname + "/public",
    filename: "bundle.js"
  },
  devServer: {
    contentBase: "./public",//本地服务器所加载的页面所在的目录
    colors: true,//终端中输出结果为彩色
    historyApiFallback: true,//不跳转
    inline: true//实时刷新
  }
}

3、Loaders
  3.1、Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如        说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适        的Loaders可以把React的JSX文件转换为JS文件。
  3.2、Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： 
     test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）
     loader：loader的名称（必须）
     include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；
     query：为loaders提供额外的设置选项（可选）


































